/**
 * @jest-environment jsdom
 */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable import/order */ // Otherwise Mocks are not working
/**
 * Mocking RestClientBase class used in RestAPIClient
 * Needs to be mocked before VersionedItemsTable import
 */
jest.mock('azure-devops-extension-api/Common/RestClientBase');

// Imports
import '@testing-library/jest-dom'
import { act } from 'react';
import { render } from '@testing-library/react';
import { screen, waitFor, waitForElementToBeRemoved, fireEvent } from '@testing-library/dom';
import { RestClientRequestParams } from 'azure-devops-extension-api/Common/RestClientBase';
import React from 'react';
import { VersionedItemLink } from '../Shared/RestAPIClient/VersionedItemLink';
import VersionedItemsTable from '../VersionedItemsTable/VersionedItemsTable'
import { LinkStatus } from '../VersionedItemsTable/VersionedItemsTableTypes';
import { mockTrackException } from '../__mocks__/@microsoft/applicationinsights-web';
import { mockGetVersionedItemLink, mockHTTPError, mockPostRequests } from '../__mocks__/azure-devops-extension-api/Common/RestClientBase';
import { mockGetItems } from '../__mocks__/azure-devops-extension-api/Git';
import { mockGetId, mockIsNew, spyWorkItemCallBackAccessor } from '../__mocks__/azure-devops-extension-sdk'

// AzDO related Mocks (implementations /src/__mocks__)
// Extension related Mocks
jest.mock('../Common');

describe('VersionedItemsTable', () => {

    beforeEach(() => {
        // Reset related mocks
        mockPostRequests.mockClear();
        mockHTTPError.mockReturnValue(false);
        mockGetItems.mockResolvedValue([]);
        mockGetVersionedItemLink.mockResolvedValue([]);
        mockTrackException.mockClear();
    });

    test('VersionedItemsTable - renders without content', async () => {

        mockGetId.mockResolvedValue(1000);
        mockGetVersionedItemLink.mockResolvedValue([]);

        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });
        
        const linkElement = screen.getByText(/Comment/i);
        expect(linkElement).toBeDefined();

    });

    test('VersionedItemsTable - renders VersionedItems', async () => {

        // prepare the test existing WorkItem with WorkItemId 999
        mockIsNew.mockReturnValue(false);
        mockGetId.mockResolvedValue(999);
        // prepare the test, one file in the git repository named somescript.py
        mockGetItems.mockReturnValue([
            {
                commitId: "commitId",
                gitObjectType: 1,
                objectId: "objectId",
                isFolder: false,
                path: "/python/somescript.py"
            }
        ]);
        mockGetVersionedItemLink.mockReturnValue([
            // Returned by GitRepo
            { "workItemId": 999, "path": "/python/somescript.py", "comment": "test", "linkStatus": "OK",
            "createdBy": "h2floh@h2floh.net", "modifiedBy": "h2floh@h2floh.net", "modifiedOn": "2020-07-10T08:45:52.167Z" },
            // Dangling/Broken Link
            { "workItemId": 999, "path": "/python/asdfasdf.py", "comment": "test", "linkStatus": "OK",
            "createdBy": "h2floh@h2floh.net", "modifiedBy": "h2floh@h2floh.net", "modifiedOn": "2020-07-10T08:45:52.167Z" }
        ]);

        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for elements to load
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText('/python/somescript.py');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        expect(screen.getAllByText('/python/somescript.py').length).toBe(1);
        expect(screen.getAllByText('The referenced file does no longer exist.').length).toBe(1);

        // Test Sort feature
        const tableHeader = screen.getByText('Link');
        await act(async () => {
            fireEvent.click(tableHeader);
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        expect(screen.getAllByRole('link')[0].firstChild?.textContent).toEqual('/python/asdfasdf.py');
    });


    test('VersionedItemsTable - test VersionedItemLink Lifecycle', async () => {
        // Increase timeout for this test
        jest.setTimeout(15000);

        mockIsNew.mockResolvedValue(false);
        mockGetId.mockResolvedValue(997);
        mockGetItems.mockReturnValue([
            {
                commitId: "commitId",
                gitObjectType: 1,
                objectId: "objectId",
                isFolder: false,
                path: "/python/somescript.py"
            }
        ]);
        mockGetVersionedItemLink.mockReturnValue([]);

        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for rendered
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText('Link');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        /**
         * Add new VersionedItem
         */
        // Search add button
        const buttons = screen.getAllByRole('button');
        // Click Add Versioned Item Link button
        await act(async () => {
            fireEvent.click(buttons[0]);
            // Small delay to ensure state updates are processed
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for empty row to appear
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText(/Created By/);
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Click Dropdown
        const dropdown = screen.getAllByRole('button');
        await act(async () => {
            fireEvent.click(dropdown[1]);
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for and select script
        let selectableItem: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!selectableItem && attempts < 10) {
                try {
                    selectableItem = screen.getByText('/python/somescript.py');
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (selectableItem) {
                fireEvent.click(selectableItem);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for somescript text to appear in the UI
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText(/somescript/);
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        
        // Add comment
        let comment: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!comment && attempts < 10) {
                try {
                    comment = screen.getByRole('textbox');
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (comment) {
                fireEvent.change(comment, { target: { value: 'commenta' } });
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Find save button
        let saveButton: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!saveButton && attempts < 10) {
                try {
                    saveButton = screen.getByLabelText(/Save icon/);
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // Press save if found
            if (saveButton) {
                fireEvent.click(saveButton);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for textbox to reappear after save
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByRole('textbox');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Evaluate save consistency to be defined
        expect(mockPostRequests.mock.calls[0][0]).toEqual('https://localhost:5000/api/versioneditem/997?api-version=2020-07-15');
        const verItemLink1 = ((mockPostRequests.mock.results[0].value as RestClientRequestParams).body) as VersionedItemLink;
        expect(verItemLink1.comment).toEqual("commenta");
        expect(verItemLink1.path).toEqual("/python/somescript.py");
        expect(verItemLink1.workItemId).toBe(997);
        expect(verItemLink1.linkStatus).toBe(LinkStatus.ok);

        /**
         * Change Comment to value 'commentar' and save
         */
        // Get textbox and change comment
        let comment2: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!comment2 && attempts < 10) {
                try {
                    comment2 = screen.getByRole('textbox');
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (comment2) {
                fireEvent.change(comment2, { target: { value: 'commentar' } });
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Find save button and click it
        let saveButton2: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!saveButton2 && attempts < 10) {
                try {
                    saveButton2 = screen.getByLabelText(/Save icon/);
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (saveButton2) {
                fireEvent.click(saveButton2);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        // Wait for textbox to reappear after save
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByRole('textbox');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Assert that the correct URL parameters were set
        expect(mockPostRequests.mock.calls[1][0]).toEqual('https://localhost:5000/api/versioneditem/997?api-version=2020-07-15');

        // Assert that comment value in the REST call payload was set to 'commentar'
        const verItemLink2 = ((mockPostRequests.mock.results[1].value as RestClientRequestParams).body) as VersionedItemLink;
        expect(verItemLink2.comment).toEqual("commentar");

        /**
         * Delete item
         */
        // Find item to delete
        let item: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!item && attempts < 10) {
                try {
                    item = screen.getByDisplayValue('commentar');
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        
        // Find and click delete button
        let deleteButton: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!deleteButton && attempts < 10) {
                try {
                    deleteButton = screen.getByLabelText(/Delete icon/);
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (deleteButton) {
                fireEvent.click(deleteButton);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        // Wait for row to disappear
        if (item) {
            await waitForElementToBeRemoved(item, { timeout: 3000 });
        }

        // Check if delete API was called
        expect(mockPostRequests.mock.calls[2][0]).toEqual('https://localhost:5000/api/versioneditem/997/delete?api-version=2020-07-15');
        const verItemLink3 = ((mockPostRequests.mock.results[2].value as RestClientRequestParams).body) as string;
        expect(verItemLink3).toEqual("/python/somescript.py");
    });

    test('VersionedItemsTable - check disable/enable AddVersionedItem button', async () => {

        // Prepare the test run, new WorkItem has no WorkItemId yet
        mockIsNew.mockReturnValue(true);
        mockGetId.mockResolvedValue(undefined);

        // Render the control
        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for the button to add a VersionedItem to appear
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.queryAllByText('Add VersionedItem Link');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        // assert that this button is disabled
        expect(screen.getByRole('button').getAttribute('aria-disabled')).toEqual("true");

        // Saving the Work Item, we simulate that the user pressed
        // the save button of the Work Item by setting isNew to false
        // and callback onSaved event with a assigned WorkItemId
        mockIsNew.mockReturnValue(false);
        await act(async () => {
            spyWorkItemCallBackAccessor().onSaved({id: 800}).catch(() => {});
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        // Wait for the button to be rerendered
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.queryAllByText('Add VersionedItem Link');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        
        // assert that the button is now enabled
        expect(screen.getByRole('button').getAttribute('aria-disabled')).toEqual(null);
    });


    test('VersionedItemsTable - Rest API access error on Add VersionedLinkItem', async () => {
        // Increase timeout for this test
        jest.setTimeout(15000);
        
        mockHTTPError.mockReturnValue(true);

        mockIsNew.mockResolvedValue(false);
        mockGetId.mockResolvedValue(700);
        mockGetItems.mockReturnValue([
            {
                commitId: "commitId",
                gitObjectType: 1,
                objectId: "objectId",
                isFolder: false,
                path: "/python/somescript.py"
            }
        ]);

        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for rendered
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.queryAllByText('Link');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        /**
         * Add new VersionedItem
         */
        // Search add button
        const buttons = screen.getAllByRole('button');
        // Click Add Versioned Item Link button
        await act(async () => {
            fireEvent.click(buttons[0]);
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for empty row to appear
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText(/Created By/);
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        
        // Click Dropdown
        const dropdown = screen.getAllByRole('button');
        await act(async () => {
            fireEvent.click(dropdown[1]);
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for and select script
        let selectableItem: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!selectableItem && attempts < 10) {
                try {
                    selectableItem = screen.getByText('/python/somescript.py');
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (selectableItem) {
                fireEvent.click(selectableItem);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for somescript text to appear in the UI
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText(/somescript/);
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        
        // Add comment
        let comment: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!comment && attempts < 10) {
                try {
                    comment = screen.getByRole('textbox');
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (comment) {
                fireEvent.change(comment, { target: { value: 'commenta' } });
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Find save button
        let saveButton: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!saveButton && attempts < 10) {
                try {
                    saveButton = screen.getByLabelText(/Save icon/);
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // Press save if found
            if (saveButton) {
                fireEvent.click(saveButton);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        // Wait for Error message to appear
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getByText('Error while trying to save.');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Evaluate save consistency to be defined
        expect(screen.getByText('Error while trying to save.')).toBeDefined();
    });


    test('VersionedItemsTable - Rest API access error on Delete VersionedLinkItem', async () => {
        // Increase timeout for this test
        jest.setTimeout(15000);

        mockIsNew.mockResolvedValue(false);
        mockGetId.mockResolvedValue(701);
        mockGetItems.mockReturnValue([
            {
                commitId: "commitId",
                gitObjectType: 1,
                objectId: "objectId",
                isFolder: false,
                path: "/python/somescript2.py"
            }
        ]);
        mockGetVersionedItemLink.mockReturnValue([
            // Returned by GitRepo
            { "workItemId": 701, "path": "/python/somescript2.py", "comment": "test", "linkStatus": "OK",
             "createdBy": "h2floh@h2floh.net", "modifiedBy": "h2floh@h2floh.net", "modifiedOn": "2020-07-10T08:45:52.167Z" },
        ]);

        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for rendered
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText(/somescript2/);
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Swith to error mode
        mockHTTPError.mockReturnValue(true);

        /**
         * Delete item
         */
        // Find delete button
        let deleteButton: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!deleteButton && attempts < 10) {
                try {
                    deleteButton = screen.getByLabelText(/Delete icon/);
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // Verify we found the path
            screen.getByText("/python/somescript2.py");
            
            // Press delete if found
            if (deleteButton) {
                fireEvent.click(deleteButton);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        // Wait for Error message to appear
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getByText('Error while trying to delete.');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Evaluate error message to be defined
        expect(screen.getByText('Error while trying to delete.')).toBeDefined();
    });

    test('VersionedItemsTable - Add/Delete VersionedItemLink without save', async () => {
        // Increase timeout for this test
        jest.setTimeout(15000);

        mockIsNew.mockResolvedValue(false);
        mockGetId.mockResolvedValue(777);
        mockGetItems.mockReturnValue([
            {
                commitId: "commitId",
                gitObjectType: 1,
                objectId: "objectId",
                isFolder: false,
                path: "/python/somescript.py"
            }
        ]);

        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for rendered
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.queryAllByText('Link');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        /**
         * Add and directly delete new VersionedItem
         */
        // Search add button
        const buttons = screen.getAllByRole('button');
        // Click Add Versioned Item Link button
        await act(async () => {
            fireEvent.click(buttons[0]);
            // Small delay to ensure state updates are processed
            await new Promise(resolve => setTimeout(resolve, 300));
        });
        
        // Wait for empty row to appear with increased timeout
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getByText(/Created By/);
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Wait for delete button to appear
        let deleteButton: HTMLElement | null = null;
        await act(async () => {
            // Use a polling approach inside act
            let attempts = 0;
            while (!deleteButton && attempts < 10) {
                try {
                    deleteButton = screen.getByLabelText(/Delete icon/);
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // Press delete
            if (deleteButton) {
                fireEvent.click(deleteButton);
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        });

        // Validate constraints
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    const buttons = screen.getAllByRole('button');
                    if (buttons.length === 1) {
                        found = true;
                    }
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });
        expect(screen.getAllByRole('button').length).toBe(1);
    });

    test('VersionedItemsTable - Git Client Error', async () => {

        // Prepare unit test
        // HTTP calls with GitClient will break
        const getItemsError = new Error('network unavailable');
        // existing WorkItem with WorkItemId 997
        mockIsNew.mockResolvedValue(false);
        mockGetId.mockResolvedValue(997);
        mockGetItems.mockRejectedValue(getItemsError);
        mockGetVersionedItemLink.mockReturnValue([]);

        // Rendering control
        await act(async () => {
            render(<VersionedItemsTable />);
            await new Promise(resolve => setTimeout(resolve, 0));
        });

        // Wait for rendering to complete
        await act(async () => {
            // Use a polling approach inside act
            let found = false;
            let attempts = 0;
            while (!found && attempts < 10) {
                try {
                    screen.getAllByText('Link');
                    found = true;
                } catch (e) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        });

        // Assert that the exception was logged
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        expect(mockTrackException.mock.calls[0][0]).toEqual({"exception": getItemsError});
    });

});
